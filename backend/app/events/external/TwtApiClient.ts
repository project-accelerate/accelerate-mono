import { Service } from 'typedi'
import { RepositoryCache } from 'backend/app/common/RepositoryCache'
import fetch from 'node-fetch'
import { keyBy, groupBy } from 'lodash'

// Generated by https://quicktype.io

export interface TwtEvent {
  id: string
  name: string
  description: string
  image?: TwtEventImage
  venue: TwtEventVenue
  date: string
  startTime: string
  durationInMinutes: number
  speakers: TwtEventSpeaker[]
  organisers: TwtEventOrganiser[]
  format?: TwtEventFormat
  tags: TwtEventStream[]
  slug: string
  stream?: TwtEventStream
  homepage?: boolean
  boosted?: boolean
}

export interface TwtEventFormat {
  id: string
  name: string
  social?: boolean
  practical?: boolean
  arts?: boolean
}

export interface TwtEventImage {
  imageUrl: string
}

export interface TwtEventOrganiser {
  id: string
  name: string
  description?: string
  twitter?: string
  website?: string
}

export interface TwtEventSpeaker {
  id: string
  name: string
  bio?: string
  shortBio?: string
  twitter?: string
}

export interface TwtEventStream {
  id: string
  name: string
}

export interface TwtEventVenue {
  id: string
  name: string
  description?: string
  address?: string
  city?: string
  postcode?: string
  location?: [number, number]
}

@Service()
export class TwtApiClient {
  private cache = new RepositoryCache({ ttl: 60_000 })

  findAllEvents(festival: string): Promise<TwtEvent[]> {
    return this.cache.resolve('findAll', { festival }, async () => {
      const res = await fetch(
        `https://api.theworldtransformed.org/festival/${festival}/event`,
      )
      if (!res.ok) {
        throw Error(await res.text())
      }

      return res.json()
    })
  }

  async findAllEventsForSpeaker(
    festival: string,
    speaker: string,
  ): Promise<TwtEvent[]> {
    const events = await this.cache.resolve(
      'findAllEventsForSpeakerIdx',
      { festival },
      async () => {
        const allEvents = await this.findAllEvents(festival)
        const eventsBySpeaker: Record<string, TwtEvent[]> = {}

        for (const e of allEvents) {
          for (const s of e.speakers) {
            eventsBySpeaker[s.id] = eventsBySpeaker[s.id] || []
            eventsBySpeaker[s.id].push(e)
          }
        }

        return eventsBySpeaker
      },
    )

    return events[speaker] || []
  }

  async findOneEvent(festival: string, id: string): Promise<TwtEvent> {
    const events = await this.cache.resolve(
      'getOneIdx',
      { festival },
      async () => {
        return keyBy(await this.findAllEvents(festival), 'id')
      },
    )

    return events[id]
  }

  async findOneSpeaker(festival: string, id: string): Promise<TwtEventSpeaker> {
    const speakers = await this.cache.resolve(
      'getSpeakerIdx',
      { festival },
      async () => {
        const events = await this.findAllEvents(festival)
        return keyBy(events.flatMap(e => e.speakers), 'id')
      },
    )

    return speakers[id]
  }

  async findOneVenue(festival: string, id: string): Promise<TwtEventVenue> {
    const venues = await this.cache.resolve(
      'getVenueIdx',
      { festival },
      async () => {
        const events = await this.findAllEvents(festival)
        return keyBy(events.map(e => e.venue), 'id')
      },
    )
    return venues[id]
  }
}
